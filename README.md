# Servo and SpiderMonkey


## Introduction

[Servo](https://github.com/servo/servo) is a Web engine--a piece of software written in Rust and implementing a host of standards which together form the Web platform--which relies on [SpiderMonkey](https://spidermonkey.dev/), itself written in C++, for its script execution capabilities(Javascript and Wasm). 
This report will provide an overview of Servo's integration of SpiderMonkey, and provide an outlook on improving the modularity of that integration. 

## Script execution and the Web

SpiderMonkey in and of itself is unrelated to the Web platform; rather, it is an implementation of the [ECMAScript specification](https://tc39.es/ecma262/), as well as of Wasm related specifications such as the [Wasm JS interface](https://webassembly.github.io/spec/js-api/index.html), [core Wasm](https://www.w3.org/TR/wasm-core/), and the [Wasm Web API](https://www.w3.org/TR/wasm-web-api/). Those capabilities are then integrated into Servo, the engine implementing the Web platform as specified by core standards such as [HTML](https://html.spec.whatwg.org/), specifications providing various types of infrastructure shared across the Web platform, such as [Web IDL](https://webidl.spec.whatwg.org/), and a host of additional specifications providing peripheral capabilities to the Web platform, such as [WebGPU](https://gpuweb.github.io/gpuweb/). 

The integration of SpiderMonkey into Servo takes places at various levels of granularity, resulting in an API surface that does not map neatly to the various specifications which Servo and SpiderMonkey are meant to implement, and resulting in a tight-coupling between Servo's implementation of various Web platform APIs and SpiderMonkey. A good example of such tight-coupling is Servo's implementation of the [Streams standard](https://streams.spec.whatwg.org), which, while not being part of EcmaScript but rather part of the Web platform, relies on an implementation provided(and now [deprecated](https://spidermonkey.dev/blog/2022/01/14/newsletter-firefox-96-97.html)) by SpiderMonkey itself. 

## SpiderMonkey: a modern script engine

SpiderMonkey is the Javascript and Wasm implementation [used in FireFox](https://firefox-source-docs.mozilla.org/js/index.html#spidermonkey). As FireFox is a modern browser with a feature-set similar to Chrome([differences between Chrome 124 and FireFox 125](https://caniuse.com/?compare=chrome+124,firefox+125&compareCats=all)), we can deduct that SpiderMonkey is a modern script execution engine with a feature-set similar to [V8](https://v8.dev/), the engine used in Chrome. 

Online forums often contains remarks about V8 outperforming SpiderMonkey, but a more in-depth look appears to relegate this idea to the urban myth. The often cited performance testing results are based on so-called synthetic test suites which have now been discredited. An example is Octane, a [retired](https://v8.dev/blog/retiring-octane) test-suite for which v8 was particularly tuned. The problem however was that this tuning was a form of over-optimization which often would slow-down real-word browsing use-cases. Modern performance test-suites such as [Speedometer](https://browserbench.org/Speedometer2.0/) are aimed at a holistic measurement of real-world browsing use-cases, and the SpiderMonkey newsletter shows the work put into improving the results of modern benchmarks([example for React](https://bugzilla.mozilla.org/show_bug.cgi?id=1867359) and [Google Docs](https://hacks.mozilla.org/2020/11/warp-improved-js-performance-in-firefox-83/)). There is no reason to believe that SpiderMonkey is generally inferior to V8 as script engine. 

## Servo's integration of SpiderMonkey

Servo being written in Rust, integration with the C++ codebase of SpiderMonkey happens via a crate of [Rust bindings](https://github.com/servo/mozjs). These bindings consists of two parts:
- `mozjs-sys`: low-level Rust bindings to the C++ API. In Servo these are used as `use js::jsapi`, `use js::jsval`, and `js::glue`.
- `mozjs`: Higher-level bindings that hide the SpiderMonkey API behind idiomatic Rust API. In Servo these are used as `use js::rust`.

## The problem of a lack of modularity

Implementation of DOM objects, part of the Web platform, are peppered with unsafe calls to `js::jsapi`: unsafe, non-idiomatic, and tightly-coupled to the SpiderMonkey API. 

Bright side: 

- There is a Web standard that defines an interface between script execution and the rest of the Web platform: [Web IDL](https://webidl.spec.whatwg.org/). 
- Some integration with SpiderMonkey is safe, idiomatic, and hides the SpiderMonkey API: see `js::rust` and the various utilities in `components/script/dom/bindings`. 
- Large part of the integration with SpiderMonkey happens automatically, through Rust code generated by a Python script found in `components/script/dom/bindings/codegen`.
- Servo's integration with SpiderMonkey is the only "browser grade"(in terms of security and features) integration with a script execution engine in Rust land. Compare with Deno problem with their [host objects](https://github.com/denoland/deno/issues/11118), or with [ExternalArrayBuffer](https://github.com/denoland/deno/issues/9799).

## The solution to the problem of a lack of modularity

### Long-term

Modular script execution by way of a trait defined by Servo that a bindings layer could implement. 
The idea is a Web IDL layer with a "bring your own JS engine" approach. 

### Short-term

- Hide `js::jsapi` behind safe and idiomatic Rust abstractions found in `components/script/dom/bindings`. 
- This also brings us closer to Web IDL spec. 